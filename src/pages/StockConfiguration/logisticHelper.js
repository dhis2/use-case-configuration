import uniq from 'lodash/uniq'
import { useAppContext } from '../../app-context'
import {
    INTEGER,
    INTEGER_POSITIVE,
    NUMBER,
    TEXT,
    WITH_REGISTRATION,
    ZERO_POSITIVE_INTEGER,
} from '../../shared'
import { flatArray } from './helper'
import { useDataElements, useTEA } from './query'

/**
 * Functions to get valid programs
 * */
const isLogisticsProgram = (program) =>
    isWithRegistration(program.programType) &&
    isRepeatableProgramStage(program) &&
    isNonAutogenerated(program.programStages)

const isWithRegistration = (programType) => programType === WITH_REGISTRATION

/**
 * Program should have only one program stage (repeatable)
 * */
const isRepeatableProgramStage = (program) => {
    const { programStages } = program
    if (programStages.length === 1) {
        return programStages[0].repeatable === true
    }
}

const isNonAutogenerated = (programStage) => {
    return programStage[0].autoGenerateEvent === false
}

/**
 * get list of programs valid for Logistics use case
 * */
export const useLogisticPrograms = () => {
    const { programs } = useAppContext()
    const { validPrograms, teaList, dataElementList } = programs.reduce(
        (accumulator, program) => {
            if (isLogisticsProgram(program) === true) {
                accumulator.validPrograms.push(program)
                const { programTrackedEntityAttributes, programStages } =
                    program
                programTrackedEntityAttributes.forEach((tea) =>
                    accumulator.teaList.push(tea.trackedEntityAttribute?.id)
                )
                programStages[0].programStageDataElements.forEach((element) =>
                    accumulator.dataElementList.push(element.dataElement)
                )
            }
            return accumulator
        },
        { validPrograms: [], teaList: [], dataElementList: [] }
    )

    return {
        programs: validPrograms,
        teas: uniq(teaList),
        dataElements: flatArray(dataElementList),
    }
}

/**
 * Get list of elements (tea, dataElements) based on valid programs
 * */
export const useLogisticsElements = () => {
    const { teas, dataElements, programs } = useLogisticPrograms()
    const { tea } = useTEA(teas)
    const { dataElement } = useDataElements(dataElements)
    const itemCode = tea && checkItemCode(tea)
    const itemDescription = tea && isItemDescription(tea)
    const {
        stockOnHand,
        distributedTo,
        stockDistributed,
        stockCorrected,
        stockCount,
        stockDiscarded,
    } = getDataElementType(dataElement)

    const programData = programs.reduce((accumulator, program) => {
        const teas = program?.programTrackedEntityAttributes.reduce(
            (accTeas, tea) => {
                if (tea?.trackedEntityAttribute?.id) {
                    accTeas.push(tea?.trackedEntityAttribute?.id)
                }
                return accTeas
            },
            []
        )

        const dataElements =
            program?.programStages[0]?.programStageDataElements.reduce(
                (accDataElements, element) => {
                    if (element?.dataElement.id) {
                        accDataElements.push(element?.dataElement.id)
                    }
                    return accDataElements
                },
                []
            )

        const itemCodeList = []
        const itemDescriptionList = []
        const stockOnHandList = []
        const distributedToList = []
        const stockDistributedList = []
        const stockCorrectedList = []
        const stockCountList = []
        const stockDiscardedList = []

        if (itemCode && itemDescription) {
            teas.forEach((tea) => {
                findSaveElement(tea, itemCode, itemCodeList)
                findSaveElement(tea, itemDescription, itemDescriptionList)
            })
        }

        if (
            stockOnHand &&
            distributedTo &&
            stockDistributed &&
            stockCorrected &&
            stockCount &&
            stockDiscarded
        ) {
            dataElements.forEach((element) => {
                findSaveElement(element, stockOnHand, stockOnHandList)
                findSaveElement(element, distributedTo, distributedToList)
                findSaveElement(element, stockDistributed, stockDistributedList)
                findSaveElement(element, stockCorrected, stockCorrectedList)
                findSaveElement(element, stockCount, stockCountList)
                findSaveElement(element, stockDiscarded, stockDiscardedList)
            })
        }

        accumulator.push({
            id: program.id,
            teas,
            dataElements,
            itemCode: itemCodeList,
            itemDescription: itemDescriptionList,
            stockOnHand: stockOnHandList,
            distributedTo: distributedToList,
            stockDistributed: stockDistributedList,
            stockCorrected: stockCorrectedList,
            stockCount: stockCountList,
            stockDiscarded: stockDiscardedList,
        })
        return accumulator
    }, [])

    return {
        programData,
        itemCode,
        stockOnHand,
        itemDescription,
        distributedTo,
        stockDistributed,
        stockCorrected,
        stockCount,
        stockDiscarded,
    }
}

const findSaveElement = (element, list, saveList) => {
    const foundElement = list.find((e) => e.id === element)
    if (foundElement) {
        saveList.push(foundElement)
    }
}

const getDataElementType = (elements) => {
    const valueTypeMap = {
        [NUMBER]: 'stockOnHand',
        [TEXT]: 'distributedTo',
        [INTEGER_POSITIVE]: ['stockDistributed', 'stockDiscarded'],
        [ZERO_POSITIVE_INTEGER]: 'stockCount',
    }

    const data =
        elements &&
        elements.reduce(
            (result, element) => {
                const { valueType } = element
                const targetArrays = valueTypeMap[valueType]
                if (targetArrays) {
                    if (Array.isArray(targetArrays)) {
                        targetArrays.forEach((array) =>
                            result[array].push(element)
                        )
                    } else {
                        result[targetArrays].push(element)
                    }
                }
                if (
                    valueType === INTEGER ||
                    valueType === INTEGER_POSITIVE ||
                    valueType === NUMBER
                ) {
                    result.stockCorrected.push(element)
                }
                return result
            },
            {
                stockOnHand: [],
                distributedTo: [],
                stockDistributed: [],
                stockCorrected: [],
                stockCount: [],
                stockDiscarded: [],
            }
        )

    return {
        stockOnHand: data?.stockOnHand,
        distributedTo: data?.distributedTo,
        stockDistributed: data?.stockDistributed,
        stockCorrected: data?.stockCorrected,
        stockCount: data?.stockCount,
        stockDiscarded: data?.stockDiscarded,
    }
}

const checkItemCode = (teas) => {
    return teas.reduce((itemCodes, tea) => {
        if (isValueTypeText(tea.valueType) && tea.unique === true) {
            return [...itemCodes, tea]
        }
        return itemCodes
    }, [])
}

const isValueTypeText = (item) => item === TEXT

export const isItemDescription = (teas) => {
    return teas.reduce((itemDescriptions, tea) => {
        if (isValueTypeText(tea.valueType)) {
            return [...itemDescriptions, tea]
        }
        return itemDescriptions
    }, [])
}
