import uniq from 'lodash/uniq'
import { useAppContext } from '../../app-context'
import {
    INTEGER,
    INTEGER_POSITIVE,
    NUMBER,
    TEXT,
    WITH_REGISTRATION,
} from '../../shared'
import { flatArray } from './helper'
import { useDataElements, useTEA } from './query'

/**
 * Functions to get valid programs
 * */
const isLogisticsProgram = (program) =>
    isWithRegistration(program.programType) &&
    isRepeatableProgramStage(program) &&
    isNonAutogenerated(program.programStages)

const isWithRegistration = (programType) => programType === WITH_REGISTRATION

/**
 * Program should have only one program stage (repeatable)
 * */
const isRepeatableProgramStage = (program) => {
    const { programStages } = program
    if (programStages.length === 1) {
        return programStages[0].repeatable === true
    }
}

const isNonAutogenerated = (programStage) => {
    return programStage[0].autoGenerateEvent === false
}

/**
 * get list of programs valid for Logistics use case
 * */
export const useLogisticPrograms = () => {
    const { programs } = useAppContext()
    const validPrograms = []
    const teaList = []
    const dataElementList = []

    programs.forEach((program) => {
        if (isLogisticsProgram(program) === true) {
            validPrograms.push(program)
        }
    })

    validPrograms.forEach((program) => {
        const { programTrackedEntityAttributes, programStages } = program
        programTrackedEntityAttributes.forEach((tea) =>
            teaList.push(tea.trackedEntityAttribute?.id)
        )
        programStages[0].programStageDataElements.forEach((element) =>
            dataElementList.push(element.dataElement)
        )
    })

    return {
        programs: validPrograms,
        teas: uniq(teaList),
        dataElements: flatArray(dataElementList),
    }
}

/**
 * Get list of elements (tea, dataElements) based on valid programs
 * */
export const useLogisticsElements = () => {
    const { teas, dataElements, programs } = useLogisticPrograms()
    const { tea } = useTEA(teas)
    const { dataElement } = useDataElements(dataElements)

    const {
        stockOnHand,
        distributedTo,
        stockDistributed,
        stockCorrected,
        stockDiscarded,
    } = getDataElementType(dataElement)
    const itemCode = tea && checkItemCode(tea)
    const itemDescription = tea && isItemDescription(tea)
    const programData = []

    programs.forEach((program) => {
        const teas = []
        const dataElements = []
        program?.programTrackedEntityAttributes.forEach((tea) =>
            teas.push(tea?.trackedEntityAttribute?.id)
        )

        program?.programStages[0]?.programStageDataElements.forEach((element) =>
            dataElements.push(element?.dataElement.id)
        )

        programData.push({
            id: program.id,
            teas,
            dataElements,
        })
    })

    programData.forEach((program) => {
        const itemCodeList = []
        const itemDescriptionList = []
        const stockOnHandList = []
        const distributedToList = []
        const stockDistributedList = []
        const stockCorrectedList = []
        const stockDiscardedList = []

        if (itemCode && itemDescription) {
            program.teas.forEach((tea) => {
                findSaveElement(tea, itemCode, itemCodeList)
                findSaveElement(tea, itemDescription, itemDescriptionList)
            })
        }

        if (
            stockOnHand &&
            distributedTo &&
            stockDistributed &&
            stockCorrected &&
            stockDiscarded
        ) {
            program.dataElements.forEach((element) => {
                findSaveElement(element, stockOnHand, stockOnHandList)
                findSaveElement(element, distributedTo, distributedToList)
                findSaveElement(element, stockDistributed, stockDistributedList)
                findSaveElement(element, stockCorrected, stockCorrectedList)
                findSaveElement(element, stockDiscarded, stockDiscardedList)
            })
        }

        program.itemCode = itemCodeList
        program.itemDescription = itemDescriptionList
        program.stockOnHand = stockOnHandList
        program.distributedTo = distributedToList
        program.stockDistributed = stockDistributedList
        program.stockCorrected = stockCorrectedList
        program.stockDiscarded = stockDiscardedList
    })

    return {
        programData,
        itemCode,
        stockOnHand,
        itemDescription,
        distributedTo,
        stockDistributed,
        stockCorrected,
        stockDiscarded,
    }
}

const findSaveElement = (element, list, saveList) => {
    const foundElement = list.find((e) => e.id === element)
    if (foundElement) {
        saveList.push(foundElement)
    }
}
const getDataElementType = (elements) => {
    const stockOnHand = []
    const distributedTo = []
    const stockDistributed = []
    const stockCorrected = []
    const stockDiscarded = []

    elements?.forEach((element) => {
        const { valueType } = element

        if (valueType === NUMBER) {
            stockOnHand.push(element)
        } else if (valueType === TEXT) {
            distributedTo.push(element)
        } else if (valueType === INTEGER_POSITIVE) {
            stockDistributed.push(element)
            stockDiscarded.push(element)
        }

        if (
            valueType === INTEGER ||
            valueType === INTEGER_POSITIVE ||
            valueType === NUMBER
        ) {
            stockCorrected.push(element)
        }
    })

    return {
        stockOnHand,
        distributedTo,
        stockDistributed,
        stockCorrected,
        stockDiscarded,
    }
}

const checkItemCode = (teas) => {
    const itemCodes = []

    teas.forEach((tea) => {
        if (isValueTypeText(tea.valueType) && tea.unique === true) {
            itemCodes.push(tea)
        }
    })

    return itemCodes
}

const isValueTypeText = (item) => item === TEXT

const isItemDescription = (teas) => {
    const itemDescriptions = []
    teas.forEach((tea) => {
        if (isValueTypeText(tea.valueType)) {
            itemDescriptions.push(tea)
        }
    })
    return itemDescriptions
}
